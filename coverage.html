
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/spacemeshos/go-spacemesh/genvm/core/context.go (82.2%)</option>
				
				<option value="file1">github.com/spacemeshos/go-spacemesh/genvm/core/hash.go (100.0%)</option>
				
				<option value="file2">github.com/spacemeshos/go-spacemesh/genvm/core/staged_cache.go (88.9%)</option>
				
				<option value="file3">github.com/spacemeshos/go-spacemesh/genvm/registry/registry.go (83.3%)</option>
				
				<option value="file4">github.com/spacemeshos/go-spacemesh/genvm/templates/wallet/handler.go (73.7%)</option>
				
				<option value="file5">github.com/spacemeshos/go-spacemesh/genvm/templates/wallet/types_scale.go (72.9%)</option>
				
				<option value="file6">github.com/spacemeshos/go-spacemesh/genvm/templates/wallet/wallet.go (75.0%)</option>
				
				<option value="file7">github.com/spacemeshos/go-spacemesh/genvm/templates/wallet/wallet_scale.go (75.0%)</option>
				
				<option value="file8">github.com/spacemeshos/go-spacemesh/genvm/vm.go (77.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package core

import (
        "bytes"
        "fmt"

        "github.com/spacemeshos/go-scale"
)

// Context serves 2 purposes:
// - maintains changes to the system state, that will be applied only after succeful execution
// - accumulates set of reusable objects and data
type Context struct {
        Loader   AccountLoader
        Handler  Handler
        Template Template

        Account Account

        Header Header
        Args   scale.Encodable

        // consumed and transfered is for MaxGas/MaxSpend validation
        consumed   uint64
        transfered uint64

        // TODO all templates for genesis will support transfers to only one account.
        // i keep it for the purposes of testing and validation (e.g we can implement more complex templates)
        // but it can be simplified down to one variable
        touched []Address
        changed map[Address]*Account
}

// Spawn account.
func (c *Context) Spawn(template Address, args scale.Encodable) error <span class="cov8" title="1">{
        principal := ComputePrincipal(template, args)
        // TODO(dshulyak) only self-spawn is supported
        if principal != c.Header.Principal </span><span class="cov0" title="0">{
                return ErrSpawn
        }</span>

        <span class="cov8" title="1">c.Account.Template = &amp;template
        return nil</span>
}

// Transfer amount to the address after validation passes.
func (c *Context) Transfer(to Address, amount uint64) error <span class="cov8" title="1">{
        if amount &gt; c.Account.Balance </span><span class="cov0" title="0">{
                return ErrNoBalance
        }</span>
        <span class="cov8" title="1">c.transfered += amount
        if c.transfered &gt; c.Header.MaxSpend </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %d", ErrMaxSpend, c.Header.MaxSpend)
        }</span>
        // noop. only gas is consumed
        <span class="cov8" title="1">if c.Account.Address == to </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if c.changed == nil </span><span class="cov8" title="1">{
                c.changed = map[Address]*Account{}
        }</span>
        <span class="cov8" title="1">account, exist := c.changed[to]
        if !exist </span><span class="cov8" title="1">{
                loaded, err := c.Loader.Get(to)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %s", ErrInternal, err.Error())
                }</span>
                <span class="cov8" title="1">c.touched = append(c.touched, to)
                c.changed[to] = &amp;loaded
                account = &amp;loaded</span>
        }

        <span class="cov8" title="1">c.Account.Balance -= amount
        account.Balance += amount
        return nil</span>
}

// Consume gas from the account after validation passes.
func (c *Context) Consume(gas uint64) error <span class="cov8" title="1">{
        amount := gas * c.Header.GasPrice
        if amount &gt; c.Account.Balance </span><span class="cov0" title="0">{
                return ErrNoBalance
        }</span>
        <span class="cov8" title="1">c.consumed += amount
        if c.consumed &gt; c.Header.MaxGas </span><span class="cov0" title="0">{
                return ErrMaxGas
        }</span>
        <span class="cov8" title="1">c.Account.Balance -= amount
        return nil</span>
}

// Apply is executed if transaction was consumed.
func (c *Context) Apply(updater AccountUpdater) error <span class="cov8" title="1">{
        buf := bytes.NewBuffer(nil)
        encoder := scale.NewEncoder(buf)
        c.Template.EncodeScale(encoder)

        c.Account.Nonce = c.Header.Nonce.Counter
        c.Account.State = buf.Bytes()
        if err := updater.Update(c.Account); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %s", ErrInternal, err.Error())
        }</span>
        <span class="cov8" title="1">for _, address := range c.touched </span><span class="cov8" title="1">{
                account := c.changed[address]
                if err := updater.Update(*account); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: %s", ErrInternal, err.Error())
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "github.com/spacemeshos/go-scale"

        "github.com/spacemeshos/go-spacemesh/hash"
)

// Hash bytes into sha256 hash.
func Hash(bufs ...[]byte) Hash32 <span class="cov8" title="1">{
        hasher := hash.New()
        for _, buf := range bufs </span><span class="cov8" title="1">{
                hasher.Write(buf)
        }</span>
        <span class="cov8" title="1">var rst Hash32
        hasher.Sum(rst[:])
        return rst</span>
}

// ComputePrincipal address as the last 20 bytes from sha256(scale(template || args)).
func ComputePrincipal(template Address, args scale.Encodable) Address <span class="cov8" title="1">{
        hasher := hash.New()
        encoder := scale.NewEncoder(hasher)
        template.EncodeScale(encoder)
        args.EncodeScale(encoder)
        hash := hasher.Sum(nil)
        var rst Address
        copy(rst[:], hash[12:])
        return rst
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "github.com/spacemeshos/go-spacemesh/common/types"
        "github.com/spacemeshos/go-spacemesh/sql"
        "github.com/spacemeshos/go-spacemesh/sql/accounts"
)

// NewStatedCache returns instance of the staged cache.
func NewStagedCache(db sql.Executor) *StagedCache <span class="cov8" title="1">{
        return &amp;StagedCache{db: db, cache: map[Address]stagedAccount{}}
}</span>

// StagedCache is a passthrough cache for accounts state and enforces order for updated accounts.
type StagedCache struct {
        db sql.Executor
        // list of changed accounts. preserving order
        touched []Address
        cache   map[Address]stagedAccount
}

// Get a copy of the Account state for the address.
func (ss *StagedCache) Get(address Address) (Account, error) <span class="cov8" title="1">{
        sacc, exist := ss.cache[address]
        if exist </span><span class="cov8" title="1">{
                return sacc.Account, nil
        }</span>
        <span class="cov8" title="1">account, err := accounts.Latest(ss.db, types.Address(address))
        if err != nil </span><span class="cov0" title="0">{
                return Account{}, err
        }</span>
        <span class="cov8" title="1">ss.cache[address] = stagedAccount{Account: account}
        return account, nil</span>
}

// Update cache with a copy of the account state.
func (ss *StagedCache) Update(account Account) error <span class="cov8" title="1">{
        sacc, exist := ss.cache[Address(account.Address)]
        if !exist || !sacc.Changed </span><span class="cov8" title="1">{
                ss.touched = append(ss.touched, Address(account.Address))
        }</span>
        <span class="cov8" title="1">ss.cache[Address(account.Address)] = stagedAccount{
                Account: account,
                Changed: true,
        }
        return nil</span>
}

// IterateChanged accounts in the order they were updated.
func (ss *StagedCache) IterateChanged(f func(*Account) bool) <span class="cov8" title="1">{
        for _, address := range ss.touched </span><span class="cov8" title="1">{
                account := ss.cache[address]
                if !f(&amp;account.Account) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

type stagedAccount struct {
        Account
        Changed bool
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package registry

import (
        "fmt"

        "github.com/spacemeshos/go-spacemesh/genvm/core"
)

var (
        reg = registry{templates: map[core.Address]core.Handler{}}
)

// Get template handler for the address if it exists.
func Get(address core.Address) core.Handler <span class="cov8" title="1">{
        return reg.get(address)
}</span>

// Register handler for the address. Panics if address is already taken.
func Register(address core.Address, api core.Handler) <span class="cov8" title="1">{
        reg.register(address, api)
}</span>

type registry struct {
        templates map[core.Address]core.Handler
}

func (r *registry) get(address core.Address) core.Handler <span class="cov8" title="1">{
        return r.templates[address]
}</span>

func (r *registry) register(address core.Address, handler core.Handler) <span class="cov8" title="1">{
        if _, exist := r.templates[address]; exist </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%x already register", address))</span>
        }
        <span class="cov8" title="1">r.templates[address] = handler</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package wallet

import (
        "bytes"
        "fmt"

        "github.com/spacemeshos/go-scale"
        "github.com/spacemeshos/go-spacemesh/genvm/core"
        "github.com/spacemeshos/go-spacemesh/genvm/registry"
)

const (
        // TotalGasSpawn is consumed from principal in case of succesful spawn.
        TotalGasSpawn = 200
        // TotalGasSpend is consumed from principal in case of succesful spend.
        TotalGasSpend = 100
)

func init() <span class="cov8" title="1">{
        TemplateAddress[len(TemplateAddress)-1] = 1
        registry.Register(TemplateAddress, &amp;handler{})
}</span>

var (
        _               (core.Handler) = (*handler)(nil)
        TemplateAddress core.Address
)

type handler struct{}

// Parse header and arguments.
func (*handler) Parse(ctx *core.Context, method uint8, decoder *scale.Decoder) (header core.Header, args scale.Encodable, err error) <span class="cov8" title="1">{
        switch method </span>{
        case 0:<span class="cov8" title="1">
                var p SpawnPayload
                if _, err = p.DecodeScale(decoder); err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%w: %s", core.ErrMalformed, err.Error())
                        return
                }</span>
                <span class="cov8" title="1">args = &amp;p.Arguments
                header.GasPrice = p.GasPrice
                header.MaxGas = TotalGasSpawn</span>
        case 1:<span class="cov8" title="1">
                var p SpendPayload
                if _, err = p.DecodeScale(decoder); err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%w: %s", core.ErrMalformed, err.Error())
                        return
                }</span>
                <span class="cov8" title="1">args = &amp;p.Arguments
                header.GasPrice = p.GasPrice
                header.Nonce.Counter = p.Nonce.Counter
                header.Nonce.Bitfield = p.Nonce.Bitfield
                header.MaxGas = TotalGasSpend</span>
        default:
        <span class="cov8" title="1">        return header, args, fm</span>t.Errorf("%w: unknown method %d", core.ErrMalformed, method)
        }
        return header, args, nil
}

// Init wallet.
</span>func (*handler) Init(method uint8, args any, state []byte) (core.Template, error) {
        i</span>f method == 0 {
        <span class="cov8" title="1">        return New(args.(*SpawnArguments)), nil
        }
        decoder := scale.NewDecoder(bytes.NewReader(state))
</span>        var wallet Wallet
        i</span>f _, err := wallet.DecodeScale(decoder); err != nil {
        <span class="cov8" title="1">        return nil, fmt.Er</span>rorf("%w: malformed state %s", core.ErrInternal, err.Error())
        }
        return &amp;wallet, nil
}

// Exec spawn o</span>r spend based on the method selector.
func (*h<span class="cov8" title="1">andler) Exec(ctx *core.Context, method uint8, args scale.Encodable) error {
        switch method {
</span>        case 0:
                i</span>f err := ctx.Consume(TotalGasSpawn); err != nil {
                <span class="cov8" title="1">        return err
</span>                }
                i</span>f err := ctx.Spawn(TemplateAddress, args); err != nil {
                        retur<span class="cov8" title="1">n err
                }
</span>        case 1:
                i</span>f err := ctx.Consume(TotalGasSpend); err != nil {
                <span class="cov8" title="1">        return err
</span>                }
                i</span>f err := ctx.Template.(*Wallet).Spend(ctx, args.(*SpendArguments)); err != nil {
                        return<span class="cov0" title="0"> err
                }
</span>        default:
        <span class="cov8" title="1">        return fm</span>t.Errorf("%w: unknown method %d", core.ErrMalformed, method)
        }
        return nil
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by github.com/spacemeshos/go-scale/scalegen. DO NOT EDIT.

package wallet

import (
        "github.com/spacemeshos/go-scale"
)

func (t *SpawnArguments) EncodeScale(enc *scale.Encoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := scale.EncodeByteArray(enc, t.PublicKey[:]); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *SpawnArguments) DecodeScale(dec *scale.Decoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := scale.DecodeByteArray(dec, t.PublicKey[:]); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *SpendArguments) EncodeScale(enc *scale.Encoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := scale.EncodeByteArray(enc, t.Destination[:]); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if n, err := scale.EncodeCompact64(enc, t.Amount); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *SpendArguments) DecodeScale(dec *scale.Decoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := scale.DecodeByteArray(dec, t.Destination[:]); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if field, n, err := scale.DecodeCompact64(dec); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
                t.Amount = field
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *SpendPayload) EncodeScale(enc *scale.Encoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := t.Arguments.EncodeScale(enc); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if n, err := t.Nonce.EncodeScale(enc); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if n, err := scale.EncodeCompact64(enc, t.GasPrice); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *SpendPayload) DecodeScale(dec *scale.Decoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := t.Arguments.DecodeScale(dec); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if n, err := t.Nonce.DecodeScale(dec); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if field, n, err := scale.DecodeCompact64(dec); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
                t.GasPrice = field
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *SpawnPayload) EncodeScale(enc *scale.Encoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := t.Arguments.EncodeScale(enc); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if n, err := scale.EncodeCompact64(enc, t.GasPrice); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *SpawnPayload) DecodeScale(dec *scale.Decoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := t.Arguments.DecodeScale(dec); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">if field, n, err := scale.DecodeCompact64(dec); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
                t.GasPrice = field
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package wallet

import (
        "fmt"

        "github.com/oasisprotocol/curve25519-voi/primitives/ed25519"

        "github.com/spacemeshos/go-spacemesh/genvm/core"
)

// New returns Wallet instance with SpawnArguments.
func New(args *SpawnArguments) *Wallet <span class="cov8" title="1">{
        return &amp;Wallet{PublicKey: args.PublicKey}
}</span>

//go:generate scalegen

// Wallet is a single-key wallet.
type Wallet struct {
        PublicKey core.PublicKey
}

// MaxSpend returns amount specified in the SpendArguments for Spend method.
func (s *Wallet) MaxSpend(method uint8, args any) (uint64, error) <span class="cov8" title="1">{
        switch method </span>{
        case 0:<span class="cov8" title="1">
                return 0, nil</span>
        case 1:<span class="cov8" title="1">
                return args.(*SpendArguments).Amount, nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("%w: unknown method %d", core.ErrMalformed, method)</span>
        }
}

// Verify that transaction is signed by the owner of the PublicKey using ed25519.
func (s *Wallet) Verify(ctx *core.Context, tx []byte) bool <span class="cov8" title="1">{
        if len(tx) &lt; 64 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">hash := core.Hash(tx[:len(tx)-64])
</span>        return ed25519.Verify(ed25519.PublicKey(s.PublicKey[:]), hash[:], tx[len(tx)-64:])
}
</span>
// Spend transfers an amount to the address specified in SpendArguments.
</span>func (s *Wallet) Spend(ctx *core.Context, args *SpendArguments) error {
        return ctx.Transfer(args.Destination, args.Amount)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by github.com/spacemeshos/go-scale/scalegen. DO NOT EDIT.

package wallet

import (
        "github.com/spacemeshos/go-scale"
)

func (t *Wallet) EncodeScale(enc *scale.Encoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := scale.EncodeByteArray(enc, t.PublicKey[:]); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}

func (t *Wallet) DecodeScale(dec *scale.Decoder) (total int, err error) <span class="cov8" title="1">{
        if n, err := scale.DecodeByteArray(dec, t.PublicKey[:]); err != nil </span><span class="cov0" title="0">{
                return total, err
        }</span> else<span class="cov8" title="1"> {
                total += n
        }</span>
        <span class="cov8" title="1">return total, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package vm

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/spacemeshos/go-scale"

        "github.com/spacemeshos/go-spacemesh/common/types"
        "github.com/spacemeshos/go-spacemesh/genvm/core"
        "github.com/spacemeshos/go-spacemesh/genvm/registry"
        _ "github.com/spacemeshos/go-spacemesh/genvm/templates/wallet"
        "github.com/spacemeshos/go-spacemesh/hash"
        "github.com/spacemeshos/go-spacemesh/log"
        "github.com/spacemeshos/go-spacemesh/sql"
        "github.com/spacemeshos/go-spacemesh/sql/accounts"
        "github.com/spacemeshos/go-spacemesh/sql/layers"
)

// Opt is for changing VM during initialization.
type Opt func(*VM)

// WithLogget sets lo</span><span class="cov8" title="1">gger for VM.
func WithLogger(logger log.Log) Opt {
        r</span>eturn func(vm *VM) {
                vm.logger = logger
        }
}

// New returns VM instance.
func New(db *sql.Database, opts ...Opt) *VM {
        vm := &amp;VM{
                logger: log.NewNop(),
                db:     db,
</span>        }
        f</span>or _, opt := range opts {
        <span class="cov8" title="1">        opt(vm)
</span>        }
        return vm
}

// VM handles modifications to the account state.
type VM struct {
        logger log.Log
        db     *sql.Database
}

// Validation initializes validation request.
func (vm *VM) Validation(raw types.RawTx) *Request {
        return &amp;Request{
                vm:      vm,
                decoder: scale.NewDecoder(bytes.NewReader(raw.Raw)),
        </span>        raw:     raw,
        }
}

// GetNonce returns expected next nonce for the address.
func (vm *VM) G</span><span class="cov0" title="0">etNonce(address core.Address) (core.Nonce, error) {
        account, err := accounts.Latest(vm.db, types.Address(address))
        i</span>f err != nil {
        <span class="cov0" title="0">        return core.Nonce{}, err
</span>        }
        return core.Nonce{Counter: account.NextNonce()}, nil
}

// ApplyGenesis saves list of accounts for genesis.
func (vm *VM) A</span><span class="cov0" title="0">pplyGenesis(genesis []types.Account) error {
        tx, err := vm.db.Tx(context.Background())
        i</span>f err != nil {
        <span class="cov8" title="1">        return err
        }
</span>        defer tx.Release()
        for i := range genesis {
                account := &amp;genesis[i]
</span>                vm.logger.With().Info("genesis account", log.Inline(account))
                i</span>f err := accounts.Update(tx, account); err != nil {
                        return fmt.Errorf("inserting genesis account %w", err)
        <span class="cov8" title="1">        }
</span>        }
        return tx.Commit()
}

// Apply transactions.
func (vm *VM) A</span><span class="cov0" title="0">pply(lid types.LayerID, txs []types.RawTx) ([]types.TransactionID, error) {
        tx, err := vm.db.Tx(context.Background())
        i</span>f err != nil {
        <span class="cov8" title="1">        return nil, err
        }
        defer tx.Release()
        var (
                ss      = core.NewStagedCache(tx)
                rd      bytes.Reader
                decoder = scale.NewDecoder(&amp;rd)
                skipped []types.TransactionID
                start   = time.Now</span><span class="cov8" title="1">()
        )
        for i := range txs {
                tx := &amp;txs[i]
                rd.Reset(tx.Ra</span><span class="cov8" title="1">w)
                header, ctx, args, err := parse(vm.logger, ss, tx.ID, decoder)
                if err != nil {
                        vm.logge</span>r.With().Warning("skipping transaction. failed to parse", log.Err(err))
                        skipped = append(skipped, tx.ID)
                <span class="cov8" title="1">        continue
                }
                vm.logger.With().Debug("applying transaction",
                        log.Object("header", header),
                        log.Object("account", &amp;ctx.Account),
</span>                )
                if ctx.Account.Balance &lt; ctx.Header.MaxGas*ctx.Header.GasPrice {
                        vm.logger.With().Warning("skipping transaction. can't cover gas",
                                log.Object("header", header),
                                log.Object("account", &amp;ctx.Account),
                        )
</span>                        skipped = append(skipped, tx.ID)
                <span class="cov8" title="1">        continue
</span>                }
                if ctx.Account.NextNonce() != ctx.Header.Nonce.Counter {
                        vm.logger.With().Warning("skipping transaction. failed nonce check",
                                log.Object("header", header),
                                log.Object("account", &amp;ctx.Account),
                        )
</span>                        skipped = append(skipped, tx.ID)
                <span class="cov8" title="1">        continue
</span>                }
                if err := ctx.Handler.Exec(ctx, ctx.Header.Method, args); err != nil {
                        vm.logger.With().Debug("transaction failed",
                                log.Object("header", header),
                                log.Object("account", &amp;ctx.Account),
                                log.Err(err),
                        )
                        // TODO anything but internal must be recorded in the execution result.
                        // internal errors are propagated up</span><span class="cov0" title="0">wards, but they are for fatal
                        // unrecovarable errors, such as disk problems
                        i</span>f errors.Is(err, core.ErrInternal) {
                                return nil, err
                <span class="cov8" title="1">        }
</span>                }
                i</span>f err := ctx.Apply(ss); err != nil {
                        return nil, fmt.Errorf("%w: %s", core.ErrInternal, err.Error())
                }
        <span class="cov8" title="1">}
</span>        // TODO move rewards here

        hasher := hash.New()
        encoder := scale.NewEncoder(hasher)
        s</span>s.IterateChanged(func(account *core.Account) bool {
        <span class="cov8" title="1">        account.Layer</span><span class="cov0" title="0"> = lid
                vm.logger.With().Debug("update account state", log.Inline(account))
                </span>err = accounts.Update(tx, account)
        <span class="cov8" title="1">        account.EncodeScale(encoder)
</span>                return err == nil
        }</span>)
        <span class="cov8" title="1">if err != nil {
                return nil, fmt.Errorf("%w: %s", core.ErrInternal, err.Error())
        }
        var hash types.Hash32
        hasher.Sum(hash[:0]</span>)
        if err := layers.UpdateStateHash(tx, lid, hash); err != nil {
                return nil, err
        }
        if err := tx.Commit(); err != nil {
                return nil, fmt.Errorf("%w: %s", core.ErrInternal, err.Error())
        }
        vm.logger.With().Info("applied transactions", lid,
                log.Int("count", len(txs)-len(skipped)),
                log.Duration("duration", time.Since(start)),
        )
        return skipped, nil
}

// Request used to implement 2-step validation flow.
// After Parse is executed - conservative cache <span class="cov8" title="1">may do validation and skip Verify
// if transaction can't be executed.
type Request st</span><span class="cov0" title="0">ruct {
        vm *VM

</span>        <span class="cov8" title="1">raw     types.RawTx
        ctx     *core.Cont</span>ext
        decoder *scale.Decoder
}

// Parse header from the raw tra<span class="cov8" title="1">nsaction.
func (r *Request)</span><span class="cov0" title="0"> Parse() (*core.Header, error) {
        header, ctx, _, err := parse(r.vm.logger, core.NewStaged</span>Cache(r.vm.db), r.raw.ID, r.decoder)
        if err != nil {
        <span class="cov8" title="1">        return nil, err
</span>        }
        r.ctx = ctx
        return header, nil
}

</span>// Verify transaction. Will panic if called without Parse completing succesfully.
fu</span>nc (r *Request) Verify() bool {
        <span class="cov8" title="1">if r.ctx == nil </span><span class="cov0" title="0">{
                panic("Verify should be called after succesfull Parse")
        }</span>
        return verify(r.ctx, r.raw.Raw)
}<span class="cov8" title="1">

</span>func parse(logger log.Log, loader core.AccountLoader, id types.TransactionID, decoder *scale.Decoder) (*core.Header, *core.Context, scale.Encodable, error) {
        v</span>ersion, _, err := scale.DecodeCompact8(decoder)
        <span class="cov8" title="1">if err != nil {
                return nil, n</span><span class="cov0" title="0">il, nil, fmt.Errorf("%w: failed to decode version %s", core.ErrMalformed, err.Error())
        }
        i</span>f version != 0 {
        <span class="cov8" title="1">        return nil, nil, nil, fmt.Errorf("%w: unsupported version %d", core.ErrMalformed, version)
        }
</span>
        v</span>ar principal core.Address
        <span class="cov8" title="1">if _, err := principal.DecodeScale(decoder); err != nil {
                return nil, nil, nil, fmt.Errorf("%w failed to decode principal: %s", core.ErrMalformed, err)
        }
        method, _, err </span><span class="cov8" title="1">:= scale.DecodeCompact8(decoder)
        if err != nil {
                return nil, nil, nil, fmt.Errorf("%w: failed to decode </span><span class="cov0" title="0">method selector %s", core.ErrMalformed, err.Error())
        }
        ac</span>count, err := loader.Get(principal)
        if err<span class="cov8" title="1"> != nil {
                return nil, nil, nil, fmt.Errorf("%w: failed load state for principal %s - %s", core.ErrInternal, principal, err)
        }</span>
        <span class="cov8" title="1">logger.With().Debug</span><span class="cov8" title="1">("loaded account state", log.Inline(&amp;account))

        v</span>ar template *core.Address
        if method == 0 {
        <span class="cov8" title="1">        template = &amp;core.Address{}
                if _, err := temp</span><span class="cov0" title="0">late.DecodeScale(decoder); err != nil {
                        return nil, nil, nil, fmt.Errorf("%w failed to decode template address %s", core.ErrMalformed, err)
                </span>}
        <span class="cov8" title="1">} else {
                template = account.Template
        }
        if template == nil {
                return nil, nil, nil, fmt.Errorf("%w: %s", core.ErrNotSpawned, principal.String())
        }

</span>        handler := registry.Get(*template)
        i</span>f handler == nil {
        <span class="cov8" title="1">        return nil, nil, nil, fmt.Errorf("%w: unknown template %s", core.ErrMalformed, *account.Template)
        }
        ctx := &amp;core.Context{
                Loader:  loader,
                Handler: handler,
                Account: account,
        }
        header, args, err := handler.Parse(ctx, method, decoder)
        if err != nil {
                return nil, n</span><span class="cov0" title="0">il, nil, err
        }
        h</span>eader.ID = id
        <span class="cov8" title="1">header.Principal = principal
        header.Templat</span><span class="cov0" title="0">e = *template
        header.Method = method

</span>        <span class="cov8" title="1">ctx.Args = args
        ctx.Header = header
</span>
        ctx.Template, err = handler.Init(method, args, account.State)
        if err != nil {
                return nil, nil, nil, err
        </span>}
        maxspend, err := ctx.Template.MaxSpend(ctx.Header.Method, args)
        if err != nil {
                return nil, nil, nil, err
        }
        ctx.Header.MaxSpend = maxspend
        return &amp;ctx.Header, ctx, args, nil
}

func verify(ctx *core.Context, raw []byte) bool {
        return ctx.Template.Verify(ctx, raw)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
