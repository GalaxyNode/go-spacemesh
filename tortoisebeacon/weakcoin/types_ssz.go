// Code generated by fastssz. DO NOT EDIT.
package weakcoin

import (
	ssz "github.com/ferranbt/fastssz"
	"github.com/spacemeshos/go-spacemesh/common/types"
)

// MarshalSSZ ssz marshals the Message object
func (m *Message) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the Message object to a target array
func (m *Message) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(24)

	// Field (0) 'Epoch'
	dst = ssz.MarshalUint32(dst, uint32(m.Epoch))

	// Field (1) 'Round'
	dst = ssz.MarshalUint32(dst, uint32(m.Round))

	// Field (2) 'Unit'
	dst = ssz.MarshalUint64(dst, m.Unit)

	// Offset (3) 'MinerPK'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.MinerPK)

	// Offset (4) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Signature)

	// Field (3) 'MinerPK'
	if len(m.MinerPK) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, m.MinerPK...)

	// Field (4) 'Signature'
	if len(m.Signature) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, m.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the Message object
func (m *Message) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 24 {
		return ssz.ErrSize
	}

	tail := buf
	var o3, o4 uint64

	// Field (0) 'Epoch'
	m.Epoch = types.EpochID(ssz.UnmarshallUint32(buf[0:4]))

	// Field (1) 'Round'
	m.Round = types.RoundID(ssz.UnmarshallUint32(buf[4:8]))

	// Field (2) 'Unit'
	m.Unit = ssz.UnmarshallUint64(buf[8:16])

	// Offset (3) 'MinerPK'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size {
		return ssz.ErrOffset
	}

	// Offset (4) 'Signature'
	if o4 = ssz.ReadOffset(buf[20:24]); o4 > size || o3 > o4 {
		return ssz.ErrOffset
	}

	// Field (3) 'MinerPK'
	{
		buf = tail[o3:o4]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(m.MinerPK) == 0 {
			m.MinerPK = make([]byte, 0, len(buf))
		}
		m.MinerPK = append(m.MinerPK, buf...)
	}

	// Field (4) 'Signature'
	{
		buf = tail[o4:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(m.Signature) == 0 {
			m.Signature = make([]byte, 0, len(buf))
		}
		m.Signature = append(m.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Message object
func (m *Message) SizeSSZ() (size int) {
	size = 24

	// Field (3) 'MinerPK'
	size += len(m.MinerPK)

	// Field (4) 'Signature'
	size += len(m.Signature)

	return
}
