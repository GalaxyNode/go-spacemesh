// Code generated by fastssz. DO NOT EDIT.
package types

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the LayerID object
func (l *LayerID) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(l)
}

// MarshalSSZTo ssz marshals the LayerID object to a target array
func (l *LayerID) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Value'
	dst = ssz.MarshalUint32(dst, l.Value)

	return
}

// UnmarshalSSZ ssz unmarshals the LayerID object
func (l *LayerID) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 4 {
		return ssz.ErrSize
	}

	// Field (0) 'Value'
	l.Value = ssz.UnmarshallUint32(buf[0:4])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the LayerID object
func (l *LayerID) SizeSSZ() (size int) {
	size = 4
	return
}

// MarshalSSZ ssz marshals the BlockEligibilityProof object
func (b *BlockEligibilityProof) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockEligibilityProof object to a target array
func (b *BlockEligibilityProof) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Field (0) 'J'
	dst = ssz.MarshalUint32(dst, b.J)

	// Offset (1) 'Sig'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Sig)

	// Field (1) 'Sig'
	if len(b.Sig) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.Sig...)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockEligibilityProof object
func (b *BlockEligibilityProof) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o1 uint64

	// Field (0) 'J'
	b.J = ssz.UnmarshallUint32(buf[0:4])

	// Offset (1) 'Sig'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size {
		return ssz.ErrOffset
	}

	// Field (1) 'Sig'
	{
		buf = tail[o1:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(b.Sig) == 0 {
			b.Sig = make([]byte, 0, len(buf))
		}
		b.Sig = append(b.Sig, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockEligibilityProof object
func (b *BlockEligibilityProof) SizeSSZ() (size int) {
	size = 8

	// Field (1) 'Sig'
	size += len(b.Sig)

	return
}

// MarshalSSZ ssz marshals the MiniBlock object
func (m *MiniBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MiniBlock object to a target array
func (m *MiniBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(89)

	// Field (0) 'LayerIndex'
	if dst, err = m.LayerIndex.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'ATXID'
	dst = append(dst, m.ATXID[:]...)

	// Offset (2) 'EligibilityProof'
	dst = ssz.WriteOffset(dst, offset)
	offset += m.EligibilityProof.SizeSSZ()

	// Offset (3) 'Data'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Data)

	// Field (4) 'Coin'
	dst = ssz.MarshalBool(dst, m.Coin)

	// Field (5) 'BaseBlock'
	dst = append(dst, m.BaseBlock[:]...)

	// Offset (6) 'AgainstDiff'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.AgainstDiff) * 20

	// Offset (7) 'ForDiff'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.ForDiff) * 20

	// Offset (8) 'NeutralDiff'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.NeutralDiff) * 20

	// Offset (9) 'TxIDs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.TxIDs) * 32

	// Offset (10) 'ActiveSet'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.ActiveSet) * 32

	// Offset (11) 'RefBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.RefBlock)

	// Field (2) 'EligibilityProof'
	if dst, err = m.EligibilityProof.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (3) 'Data'
	if len(m.Data) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, m.Data...)

	// Field (6) 'AgainstDiff'
	if len(m.AgainstDiff) > 1024 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(m.AgainstDiff); ii++ {
		dst = append(dst, m.AgainstDiff[ii][:]...)
	}

	// Field (7) 'ForDiff'
	if len(m.ForDiff) > 1024 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(m.ForDiff); ii++ {
		dst = append(dst, m.ForDiff[ii][:]...)
	}

	// Field (8) 'NeutralDiff'
	if len(m.NeutralDiff) > 1024 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(m.NeutralDiff); ii++ {
		dst = append(dst, m.NeutralDiff[ii][:]...)
	}

	// Field (9) 'TxIDs'
	if len(m.TxIDs) > 1024 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(m.TxIDs); ii++ {
		dst = append(dst, m.TxIDs[ii][:]...)
	}

	// Field (10) 'ActiveSet'
	if len(m.ActiveSet) > 1024 {
		err = ssz.ErrListTooBig
		return
	}
	for ii := 0; ii < len(m.ActiveSet); ii++ {
		dst = append(dst, m.ActiveSet[ii][:]...)
	}

	// Field (11) 'RefBlock'
	if len(m.RefBlock) > 20 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, m.RefBlock...)

	return
}

// UnmarshalSSZ ssz unmarshals the MiniBlock object
func (m *MiniBlock) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 89 {
		return ssz.ErrSize
	}

	tail := buf
	var o2, o3, o6, o7, o8, o9, o10, o11 uint64

	// Field (0) 'LayerIndex'
	if err = m.LayerIndex.UnmarshalSSZ(buf[0:4]); err != nil {
		return err
	}

	// Field (1) 'ATXID'
	copy(m.ATXID[:], buf[4:36])

	// Offset (2) 'EligibilityProof'
	if o2 = ssz.ReadOffset(buf[36:40]); o2 > size {
		return ssz.ErrOffset
	}

	// Offset (3) 'Data'
	if o3 = ssz.ReadOffset(buf[40:44]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (4) 'Coin'
	m.Coin = ssz.UnmarshalBool(buf[44:45])

	// Field (5) 'BaseBlock'
	copy(m.BaseBlock[:], buf[45:65])

	// Offset (6) 'AgainstDiff'
	if o6 = ssz.ReadOffset(buf[65:69]); o6 > size || o3 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'ForDiff'
	if o7 = ssz.ReadOffset(buf[69:73]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Offset (8) 'NeutralDiff'
	if o8 = ssz.ReadOffset(buf[73:77]); o8 > size || o7 > o8 {
		return ssz.ErrOffset
	}

	// Offset (9) 'TxIDs'
	if o9 = ssz.ReadOffset(buf[77:81]); o9 > size || o8 > o9 {
		return ssz.ErrOffset
	}

	// Offset (10) 'ActiveSet'
	if o10 = ssz.ReadOffset(buf[81:85]); o10 > size || o9 > o10 {
		return ssz.ErrOffset
	}

	// Offset (11) 'RefBlock'
	if o11 = ssz.ReadOffset(buf[85:89]); o11 > size || o10 > o11 {
		return ssz.ErrOffset
	}

	// Field (2) 'EligibilityProof'
	{
		buf = tail[o2:o3]
		if err = m.EligibilityProof.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (3) 'Data'
	{
		buf = tail[o3:o6]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		if cap(m.Data) == 0 {
			m.Data = make([]byte, 0, len(buf))
		}
		m.Data = append(m.Data, buf...)
	}

	// Field (6) 'AgainstDiff'
	{
		buf = tail[o6:o7]
		num, err := ssz.DivideInt2(len(buf), 20, 1024)
		if err != nil {
			return err
		}
		m.AgainstDiff = make([]BlockID, num)
		for ii := 0; ii < num; ii++ {
			copy(m.AgainstDiff[ii][:], buf[ii*20:(ii+1)*20])
		}
	}

	// Field (7) 'ForDiff'
	{
		buf = tail[o7:o8]
		num, err := ssz.DivideInt2(len(buf), 20, 1024)
		if err != nil {
			return err
		}
		m.ForDiff = make([]BlockID, num)
		for ii := 0; ii < num; ii++ {
			copy(m.ForDiff[ii][:], buf[ii*20:(ii+1)*20])
		}
	}

	// Field (8) 'NeutralDiff'
	{
		buf = tail[o8:o9]
		num, err := ssz.DivideInt2(len(buf), 20, 1024)
		if err != nil {
			return err
		}
		m.NeutralDiff = make([]BlockID, num)
		for ii := 0; ii < num; ii++ {
			copy(m.NeutralDiff[ii][:], buf[ii*20:(ii+1)*20])
		}
	}

	// Field (9) 'TxIDs'
	{
		buf = tail[o9:o10]
		num, err := ssz.DivideInt2(len(buf), 32, 1024)
		if err != nil {
			return err
		}
		m.TxIDs = make([]TransactionID, num)
		for ii := 0; ii < num; ii++ {
			copy(m.TxIDs[ii][:], buf[ii*32:(ii+1)*32])
		}
	}

	// Field (10) 'ActiveSet'
	{
		buf = tail[o10:o11]
		num, err := ssz.DivideInt2(len(buf), 32, 1024)
		if err != nil {
			return err
		}
		m.ActiveSet = make([]ATXID, num)
		for ii := 0; ii < num; ii++ {
			copy(m.ActiveSet[ii][:], buf[ii*32:(ii+1)*32])
		}
	}

	// Field (11) 'RefBlock'
	{
		buf = tail[o11:]
		if len(buf) > 20 {
			return ssz.ErrBytesLength
		}
		if cap(m.RefBlock) == 0 {
			m.RefBlock = make([]byte, 0, len(buf))
		}
		m.RefBlock = append(m.RefBlock, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MiniBlock object
func (m *MiniBlock) SizeSSZ() (size int) {
	size = 89

	// Field (2) 'EligibilityProof'
	size += m.EligibilityProof.SizeSSZ()

	// Field (3) 'Data'
	size += len(m.Data)

	// Field (6) 'AgainstDiff'
	size += len(m.AgainstDiff) * 20

	// Field (7) 'ForDiff'
	size += len(m.ForDiff) * 20

	// Field (8) 'NeutralDiff'
	size += len(m.NeutralDiff) * 20

	// Field (9) 'TxIDs'
	size += len(m.TxIDs) * 32

	// Field (10) 'ActiveSet'
	size += len(m.ActiveSet) * 32

	// Field (11) 'RefBlock'
	size += len(m.RefBlock)

	return
}

// MarshalSSZ ssz marshals the Block object
func (b *Block) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the Block object to a target array
func (b *Block) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'MiniBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += b.MiniBlock.SizeSSZ()

	// Offset (1) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Signature)

	// Field (0) 'MiniBlock'
	if dst, err = b.MiniBlock.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	if len(b.Signature) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, b.Signature...)

	return
}

// UnmarshalSSZ ssz unmarshals the Block object
func (b *Block) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'MiniBlock'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'Signature'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'MiniBlock'
	{
		buf = tail[o0:o1]
		if err = b.MiniBlock.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Signature'
	{
		buf = tail[o1:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(b.Signature) == 0 {
			b.Signature = make([]byte, 0, len(buf))
		}
		b.Signature = append(b.Signature, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Block object
func (b *Block) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'MiniBlock'
	size += b.MiniBlock.SizeSSZ()

	// Field (1) 'Signature'
	size += len(b.Signature)

	return
}

// MarshalSSZ ssz marshals the DBBlock object
func (d *DBBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DBBlock object to a target array
func (d *DBBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(32)

	// Offset (0) 'MiniBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += d.MiniBlock.SizeSSZ()

	// Field (1) 'ID'
	dst = append(dst, d.ID[:]...)

	// Offset (2) 'Signature'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(d.Signature)

	// Offset (3) 'MinerID'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(d.MinerID)

	// Field (0) 'MiniBlock'
	if dst, err = d.MiniBlock.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Signature'
	if len(d.Signature) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, d.Signature...)

	// Field (3) 'MinerID'
	if len(d.MinerID) > 256 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, d.MinerID...)

	return
}

// UnmarshalSSZ ssz unmarshals the DBBlock object
func (d *DBBlock) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 32 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o2, o3 uint64

	// Offset (0) 'MiniBlock'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Field (1) 'ID'
	copy(d.ID[:], buf[4:24])

	// Offset (2) 'Signature'
	if o2 = ssz.ReadOffset(buf[24:28]); o2 > size || o0 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'MinerID'
	if o3 = ssz.ReadOffset(buf[28:32]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (0) 'MiniBlock'
	{
		buf = tail[o0:o2]
		if err = d.MiniBlock.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (2) 'Signature'
	{
		buf = tail[o2:o3]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(d.Signature) == 0 {
			d.Signature = make([]byte, 0, len(buf))
		}
		d.Signature = append(d.Signature, buf...)
	}

	// Field (3) 'MinerID'
	{
		buf = tail[o3:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(d.MinerID) == 0 {
			d.MinerID = make([]byte, 0, len(buf))
		}
		d.MinerID = append(d.MinerID, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the DBBlock object
func (d *DBBlock) SizeSSZ() (size int) {
	size = 32

	// Field (0) 'MiniBlock'
	size += d.MiniBlock.SizeSSZ()

	// Field (2) 'Signature'
	size += len(d.Signature)

	// Field (3) 'MinerID'
	size += len(d.MinerID)

	return
}
