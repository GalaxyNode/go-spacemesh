// Code generated by fastssz. DO NOT EDIT.
package p2p

import (
	ssz "github.com/ferranbt/fastssz"
	"github.com/spacemeshos/go-spacemesh/p2p/service"
)

// MarshalSSZ ssz marshals the ProtocolMessageMetadata object
func (p *ProtocolMessageMetadata) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProtocolMessageMetadata object to a target array
func (p *ProtocolMessageMetadata) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(24)

	// Offset (0) 'NextProtocol'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.NextProtocol)

	// Offset (1) 'ClientVersion'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.ClientVersion)

	// Field (2) 'Timestamp'
	dst = ssz.MarshalUint64(dst, p.Timestamp)

	// Offset (3) 'AuthPubkey'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.AuthPubkey)

	// Field (4) 'NetworkID'
	dst = ssz.MarshalUint32(dst, p.NetworkID)

	// Field (0) 'NextProtocol'
	if len(p.NextProtocol) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, []byte(p.NextProtocol)...)

	// Field (1) 'ClientVersion'
	if len(p.ClientVersion) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, []byte(p.ClientVersion)...)

	// Field (3) 'AuthPubkey'
	if len(p.AuthPubkey) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.AuthPubkey...)

	return
}

// UnmarshalSSZ ssz unmarshals the ProtocolMessageMetadata object
func (p *ProtocolMessageMetadata) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 24 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o3 uint64

	// Offset (0) 'NextProtocol'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'ClientVersion'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (2) 'Timestamp'
	p.Timestamp = ssz.UnmarshallUint64(buf[8:16])

	// Offset (3) 'AuthPubkey'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o1 > o3 {
		return ssz.ErrOffset
	}

	// Field (4) 'NetworkID'
	p.NetworkID = ssz.UnmarshallUint32(buf[20:24])

	// Field (0) 'NextProtocol'
	{
		buf = tail[o0:o1]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		p.NextProtocol = string(buf)
	}

	// Field (1) 'ClientVersion'
	{
		buf = tail[o1:o3]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		p.ClientVersion = string(buf)
	}

	// Field (3) 'AuthPubkey'
	{
		buf = tail[o3:]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		if cap(p.AuthPubkey) == 0 {
			p.AuthPubkey = make([]byte, 0, len(buf))
		}
		p.AuthPubkey = append(p.AuthPubkey, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProtocolMessageMetadata object
func (p *ProtocolMessageMetadata) SizeSSZ() (size int) {
	size = 24

	// Field (0) 'NextProtocol'
	size += len(p.NextProtocol)

	// Field (1) 'ClientVersion'
	size += len(p.ClientVersion)

	// Field (3) 'AuthPubkey'
	size += len(p.AuthPubkey)

	return
}

// MarshalSSZ ssz marshals the Payload object
func (p *Payload) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the Payload object to a target array
func (p *Payload) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Payload'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.Payload)

	// Offset (1) 'Wrapped'
	dst = ssz.WriteOffset(dst, offset)
	if p.Wrapped == nil {
		p.Wrapped = new(service.DataMsgWrapper)
	}
	offset += p.Wrapped.SizeSSZ()

	// Field (0) 'Payload'
	if len(p.Payload) > 4096 {
		err = ssz.ErrBytesLength
		return
	}
	dst = append(dst, p.Payload...)

	// Field (1) 'Wrapped'
	if dst, err = p.Wrapped.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Payload object
func (p *Payload) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'Payload'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'Wrapped'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'Payload'
	{
		buf = tail[o0:o1]
		if len(buf) > 4096 {
			return ssz.ErrBytesLength
		}
		if cap(p.Payload) == 0 {
			p.Payload = make([]byte, 0, len(buf))
		}
		p.Payload = append(p.Payload, buf...)
	}

	// Field (1) 'Wrapped'
	{
		buf = tail[o1:]
		if p.Wrapped == nil {
			p.Wrapped = new(service.DataMsgWrapper)
		}
		if err = p.Wrapped.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Payload object
func (p *Payload) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Payload'
	size += len(p.Payload)

	// Field (1) 'Wrapped'
	if p.Wrapped == nil {
		p.Wrapped = new(service.DataMsgWrapper)
	}
	size += p.Wrapped.SizeSSZ()

	return
}

// MarshalSSZ ssz marshals the ProtocolMessage object
func (p *ProtocolMessage) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProtocolMessage object to a target array
func (p *ProtocolMessage) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'Metadata'
	dst = ssz.WriteOffset(dst, offset)
	if p.Metadata == nil {
		p.Metadata = new(ProtocolMessageMetadata)
	}
	offset += p.Metadata.SizeSSZ()

	// Offset (1) 'Payload'
	dst = ssz.WriteOffset(dst, offset)
	if p.Payload == nil {
		p.Payload = new(Payload)
	}
	offset += p.Payload.SizeSSZ()

	// Field (0) 'Metadata'
	if dst, err = p.Metadata.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Payload'
	if dst, err = p.Payload.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ProtocolMessage object
func (p *ProtocolMessage) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'Metadata'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	// Offset (1) 'Payload'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'Metadata'
	{
		buf = tail[o0:o1]
		if p.Metadata == nil {
			p.Metadata = new(ProtocolMessageMetadata)
		}
		if err = p.Metadata.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Payload'
	{
		buf = tail[o1:]
		if p.Payload == nil {
			p.Payload = new(Payload)
		}
		if err = p.Payload.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProtocolMessage object
func (p *ProtocolMessage) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'Metadata'
	if p.Metadata == nil {
		p.Metadata = new(ProtocolMessageMetadata)
	}
	size += p.Metadata.SizeSSZ()

	// Field (1) 'Payload'
	if p.Payload == nil {
		p.Payload = new(Payload)
	}
	size += p.Payload.SizeSSZ()

	return
}
